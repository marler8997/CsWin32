using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Metadata;
using System.Reflection.PortableExecutable;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis.CSharp.Syntax;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

public static partial class ZigWin32
{
    private static readonly Dictionary<string, string> zig_keyword_id_map = new Dictionary<string, string>();

    static ZigWin32()
    {
        foreach (string keyword in ZigLanguageData.keywords)
        {
            zig_keyword_id_map.Add(keyword, string.Format("@\"{0}\"", keyword));
        }
    }

    public class ZigGenerator
    {
        internal const string WindowsWin32NamespacePrefix = "Windows.Win32.";
        private const string AutogeneratedMessage = "//! NOTE: this source file is autogenerated, DO NOT MODIFY";
        private const string Win32Zig = @"
pub const api = @import(""win32/api.zig"");
// TODO glue? header?

test """" {
    @import(""std"").testing.refAllDecls(@This());
}
";

        private readonly MetadataReader mr;
        private readonly CancellationToken cancel_token;
        private readonly Dictionary<string, TypeGenInfo> no_namespace_type_map = new Dictionary<string, TypeGenInfo>();
        private readonly Dictionary<string, Api> api_namespace_map = new Dictionary<string, Api>();
        private readonly Dictionary<TypeDefinitionHandle, TypeGenInfo> type_map = new Dictionary<TypeDefinitionHandle, TypeGenInfo>();
        private readonly TypeRefDecoder type_ref_decoder;

        private ZigGenerator(MetadataReader mr, CancellationToken cancel_token)
        {
            this.mr = mr;
            this.cancel_token = cancel_token;
            foreach (TypeDefinitionHandle type_def_handle in this.mr.TypeDefinitions)
            {
                TypeGenInfo type_info = new TypeGenInfo(this.mr, type_def_handle);
                bool is_constant_type = type_info.name == "Apis";
                if (!is_constant_type)
                {
                    this.type_map.Add(type_def_handle, type_info);
                }

                if (type_info.@namespace.Length == 0)
                {
                    Debug.Assert(!is_constant_type, "found Apis types in the empty namespace");

                    if (this.no_namespace_type_map.ContainsKey(type_info.name))
                    {
                        // https://github.com/microsoft/CsWin32/issues/31
                        if (!KnownIssues.no_namespace_type_conflicts.Contains(type_info.name))
                        {
                            throw new InvalidDataException(string.Format("new type conflict '{0}', add to KnownIssues.no_namespace_type_conflicts", type_info.name));
                        }
                    }
                    else
                    {
                        this.no_namespace_type_map.Add(type_info.name, type_info);
                    }
                }
                else
                {
                    Api? api;
                    if (!this.api_namespace_map.TryGetValue(type_info.@namespace, out api))
                    {
                        api = new Api(type_info.@namespace);
                        this.api_namespace_map.Add(type_info.@namespace, api);
                    }

                    if (is_constant_type)
                    {
                        Debug.Assert(api.constants == null, "multiple Apis types in the same namespace");
                        api.constants = type_info.def.GetFields();
                    }
                    else
                    {
                        api.addType(type_info);
                    }
                }
            }
            this.type_ref_decoder = new TypeRefDecoder(this.no_namespace_type_map, this.api_namespace_map, this.type_map);
        }

        public static void Generate(MetadataReader mr, string out_dir, CancellationToken cancel_token)
        {
            ZigGenerator generator = new ZigGenerator(mr, cancel_token);

            {
                var win32_filename = Path.Combine(out_dir, "win32.zig");
                using var file_stream = new FileStream(win32_filename, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                out_file.Write(Win32Zig);
            }

            string win32_dir = Path.Combine(out_dir, "win32");
            Directory.CreateDirectory(win32_dir);

            string api_dir = Path.Combine(win32_dir, "api");
            Directory.CreateDirectory(api_dir);

            foreach (Api api in generator.api_namespace_map.Values)
            {
                string filepath = Path.Combine(api_dir, api.base_filename);
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                Console.WriteLine("Api: {0}", api.name);
                generator.GenerateApi(out_file, api);
            }

            {
                string filepath = Path.Combine(win32_dir, "api.zig");
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                foreach (Api api in generator.api_namespace_map.Values)
                {
                    out_file.WriteLine(@"pub const {0} = @import(""api/{1}"");", api.name_lower, api.base_filename);
                }

                out_file.WriteLine(@"test """" {{");
                out_file.WriteLine(@"    const api_count = {0};", generator.api_namespace_map.Count);
                out_file.WriteLine(@"    @setEvalBranchQuota(api_count);");
                out_file.WriteLine(@"    @import(""std"").testing.refAllDecls(@This());");
                out_file.WriteLine(@"}}");
            }
        }

        private void GenerateApi(StreamWriter out_file, Api api)
        {
            out_file.WriteLine(AutogeneratedMessage);
            out_file.WriteLine();
            out_file.WriteLine("//");
            out_file.WriteLine("// constants");
            out_file.WriteLine("//");
            uint const_count = 0;
            if (api.constants != null)
            {
                foreach (FieldDefinitionHandle field_def in api.constants)
                {
                    this.cancel_token.ThrowIfCancellationRequested();
                    this.GenerateConstant(out_file, field_def);
                    const_count += 1;
                }
            }

            TypeGenInfoSet type_refs = new TypeGenInfoSet();
            out_file.WriteLine("//");
            out_file.WriteLine("// types");
            out_file.WriteLine("//");
            uint type_count = 0;
            foreach (TypeGenInfo type_info in api.types)
            {
                this.cancel_token.ThrowIfCancellationRequested();
                this.GenerateType(out_file, type_refs, type_info);
                type_count += 1;
            }

            out_file.WriteLine("//");
            out_file.WriteLine("// type imports");
            out_file.WriteLine("//");
            uint type_import_count = 0;
            foreach (TypeGenInfo type_ref in type_refs)
            {
                if (!api.types.contains(type_ref))
                {
                    if (api.type_name_fqn_map.TryGetValue(type_ref.name, out string? local_fqn))
                    {
                        if (type_ref.@namespace.Length != 0)
                        {
                            throw new InvalidOperationException(string.Format(
                                "TypeConflict between '{0}' and one with a non-empty namespace '{1}'",
                                local_fqn,
                                type_ref.fqn));
                        }

                        // TODO: file and/or find an issue for this, this is a bug in win32metadata
                        out_file.WriteLine(
                            "// !!!TypeConflict!!! local type '{0}' conflicts with a type that has no namespace (TODO: file or find an issue for this in win32metadata)'",
                            local_fqn);
                    }
                    else
                    {
                        out_file.WriteLine("const {0} = *opaque{{}}; // TODO: import it", type_ref.name);
                        type_import_count += 1;
                    }
                }
            }

            out_file.WriteLine();
            out_file.WriteLine("test \"\" {{");
            out_file.WriteLine("    const constant_export_count = {0};", const_count);
            out_file.WriteLine("    const type_export_count = {0};", type_count);
            out_file.WriteLine("    const type_import_count = {0};", type_import_count);
            out_file.WriteLine("    @setEvalBranchQuota(constant_export_count + type_export_count + type_import_count + 2); // TODO: why do I need these extra 2?");
            out_file.WriteLine("    @import(\"std\").testing.refAllDecls(@This());");
            out_file.WriteLine("}}");
        }

        private void GenerateConstant(StreamWriter out_file, FieldDefinitionHandle fieldDefHandle)
        {
            FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);

            FieldAttributes expected = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal | FieldAttributes.HasDefault;
            if (fieldDef.Attributes != expected)
            {
                throw new InvalidOperationException(string.Format(
                    "Expected Constant FieldDefinition to have these attributes '{0}' but got '{1}'", expected, fieldDef.Attributes));
            }

            Debug.Assert(fieldDef.GetOffset() == -1, "Constant unexpectedly has an offset");
            Debug.Assert(fieldDef.GetRelativeVirtualAddress() == 0, "Constant unexpectedly has non-zero virtual address");

            // TODO: what is this signature?
            byte[] signature = this.mr.GetBlobBytes(fieldDef.Signature);

            // out_file.WriteLine("// signature (TODO: what is this for?) {0} bytes: {1}", signature.Length, BitConverter.ToString(signature));

            // TODO: handle custom attributes
            // TODO: what is fieldDef.GetMarshallingDescriptor?
            foreach (CustomAttributeHandle attrHandle in fieldDef.GetCustomAttributes())
            {
                var attr = this.mr.GetCustomAttribute(attrHandle);

                // TODO: what to do with this?
                /*
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(GuidAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    guid = Guid.Parse((string)args.FixedArguments[0].Value!);
                }
                */
            }

            // NOTE: fieldDef.GetDeclaringType returns the type that contains the Constant
            //       I will probably use this to know where to put the constant but it has nothing
            //       to do with the type of the constant.
            // TypeGenInfo containingTypeInfo = this.GetTypeGenInfo(fieldDef.GetDeclaringType());
            string name = this.mr.GetString(fieldDef.Name);
            Constant constant = this.mr.GetConstant(fieldDef.GetDefaultValue());
            var assign = toZigConstAssign(constant, this.mr);
            if (assign.optional_type == null)
            {
                out_file.WriteLine("pub const {0} = {1};", name, assign.literal);
            }
            else
            {
                out_file.WriteLine("pub const {0} : {1} = {2};", name, assign.optional_type, assign.literal);
            }
        }

        private void GenerateType(StreamWriter out_file, TypeGenInfoSet type_refs, TypeGenInfo type_info)
        {
            out_file.WriteLine("// --------------------------------------------------------");
            out_file.WriteLine("// Type: {0}", type_info.name);
            out_file.WriteLine("// Nested: {0}", type_info.def.IsNested);

            DecodedTypeAttributes attrs = new DecodedTypeAttributes(type_info.def.Attributes);

            out_file.WriteLine("// Attributes: {0}", attrs);

            TypeGenInfo? optional_declaring_type = null;
            if (type_info.def.IsNested)
            {
                TypeGenInfo declaring_type = this.type_map[type_info.def.GetDeclaringType()];
                optional_declaring_type = declaring_type;
                out_file.WriteLine("// DeclaringType: {0} (namespace={1})", declaring_type.name, declaring_type.@namespace);
            }
            else
            {
                Debug.Assert(type_info.def.GetDeclaringType().IsNil, "unexpected data");
                out_file.WriteLine("// DeclaringType: <null>");
            }

            /*
             * TODO: look at these Methods on TypeDefinition as well
            type_info.def.GetCustomAttributes()
            type_info.def.GetDeclarativeSecurityAttributes()
            public EventDefinitionHandleCollection GetEvents();
            public FieldDefinitionHandleCollection GetFields();
            public GenericParameterHandleCollection GetGenericParameters();
            public InterfaceImplementationHandleCollection GetInterfaceImplementations();
            public TypeLayout GetLayout();
            public MethodImplementationHandleCollection GetMethodImplementations();
            public MethodDefinitionHandleCollection GetMethods();
            // Summary:
            //     Returns an array of types nested in the specified type.
            // Returns:
            //     An immutable array of type definition handles that represent types nested in
            //     the specified type.
            public ImmutableArray<TypeDefinitionHandle> GetNestedTypes();
            public PropertyDefinitionHandleCollection GetProperties();
            */

            string? skip_because = null;
            if (type_info.def.IsNested)
            {
                skip_because = "its a nested type";
            }
            else if (attrs.is_abstract)
            {
                skip_because = "its an abstract type";
            }
            else if (attrs.visibility != TypeVisibility.@public)
            {
                skip_because = "its a non-public type";
            }
            else if (!attrs.is_sealed)
            {
                skip_because = "its a non-sealed type";
            }
            else if (attrs.layout == TypeLayout2.@explicit)
            {
                skip_because = "it has an explicit layout";
            }
            else if (attrs.layout == TypeLayout2.@auto)
            {
                skip_because = "it has an 'auto' layout";
            }
            else if (attrs.class_semantics == TypeClassSemantics.@interface)
            {
                skip_because = "it is an interface type";
            }

            if (skip_because != null)
            {
                out_file.WriteLine("// not generate proper code for this type because {0}", skip_because);
                out_file.WriteLine("pub const {0} = *opaque{{}};", type_info.name);
                return;
            }

            out_file.WriteLine("// TODO: I think this is a struct, but not sure at this point, assuming it is for now");
            out_file.WriteLine("pub const {0} = extern struct {{", type_info.name);
            foreach (FieldDefinitionHandle field_def_handle in type_info.def.GetFields())
            {
                FieldDefinition field_def = this.mr.GetFieldDefinition(field_def_handle);
                string field_type_zig = addTypeRef(type_refs, field_def.DecodeSignature(this.type_ref_decoder, null));
                out_file.WriteLine("    {0}: *opaque{{}}, // {1}", escapeZigId(this.mr.GetString(field_def.Name)), field_type_zig);
            }
            out_file.WriteLine("};");
        }
    }

    internal class Api
    {
        public readonly string name;
        public readonly string name_lower;
        public readonly string base_filename;
        public readonly TypeGenInfoSet types = new TypeGenInfoSet();
        public readonly Dictionary<string, string> type_name_fqn_map = new Dictionary<string, string>();
        public FieldDefinitionHandleCollection? constants;
        public readonly HashSet<TypeGenInfo> type_imports = new HashSet<TypeGenInfo>();

        public Api(string @namespace)
        {
            if (!@namespace.StartsWith(ZigGenerator.WindowsWin32NamespacePrefix, StringComparison.Ordinal))
            {
                throw new InvalidDataException(string.Format(
                    "Unexpected namespace '{0}', expected it to start with '{1}'",
                    @namespace,
                    ZigGenerator.WindowsWin32NamespacePrefix));
            }
            this.name = @namespace.Substring(ZigGenerator.WindowsWin32NamespacePrefix.Length);
            this.name_lower = this.name.ToLowerInvariant();
            this.base_filename = this.name_lower + ".zig";
        }

        internal void addType(TypeGenInfo type_info)
        {
            this.types.Add(type_info);
            this.type_name_fqn_map.Add(type_info.name, type_info.fqn);
        }
    }

    // I've purposely combined adding a type ref and creating the Zig
    // type string so I don't accidently generate a type without noting
    // that I'm referencing it.
    private static string addTypeRef(TypeGenInfoSet type_refs, TypeRef type_ref)
    {
        type_ref.addTypeRefs(type_refs);
        StringBuilder builder = new StringBuilder();
        type_ref.formatZigType(builder);
        return builder.ToString();
    }

    private static string escapeZigId(string id)
    {
        string? zig_id;
        if (zig_keyword_id_map.TryGetValue(id, out zig_id))
        {
            return zig_id;
        }
        return id;
    }

    private static ZigConstAssign toZigConstAssign(Constant constant, MetadataReader mr)
    {
        return toZigConstAssignImpl(constant.TypeCode, mr.GetBlobReader(constant.Value));
    }

    private static ZigConstAssign toZigConstAssignImpl(ConstantTypeCode typeCode, BlobReader blobReader)
    {
        return typeCode switch
        {
            ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? new ZigConstAssign("true") : new ZigConstAssign("false"),
            ConstantTypeCode.Char => new ZigConstAssign(string.Format("'{0}'", blobReader.ReadChar())),
            ConstantTypeCode.SByte => new ZigConstAssign(string.Format("{0}", blobReader.ReadSByte()), "i8"),
            ConstantTypeCode.Byte => new ZigConstAssign(string.Format("{0}", blobReader.ReadByte()), "u8"),
            ConstantTypeCode.Int16 => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt16()), "i16"),
            ConstantTypeCode.UInt16 => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt16()), "u16"),
            ConstantTypeCode.Int32 => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt32()), "i32"),
            ConstantTypeCode.UInt32 => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt32()), "u32"),
            ConstantTypeCode.Int64 => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt64()), "i64"),
            ConstantTypeCode.UInt64 => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt64()), "u64"),
            ConstantTypeCode.Single => GetSingle(blobReader.ReadSingle()),
            ConstantTypeCode.Double => GetDouble(blobReader.ReadDouble()),
            ConstantTypeCode.String => GetString(blobReader.ReadConstant(ConstantTypeCode.String)),
            ConstantTypeCode.NullReference => new ZigConstAssign("null"),
            _ => throw new NotSupportedException("ConstantTypeCode not supported: " + typeCode),
        };
        static ZigConstAssign GetString(object? obj)
        {
            return obj is string value ?
                new ZigConstAssign(string.Format("\"{0}\"", value)) :
                throw new Exception(string.Format("String constant is not a string? it is: {0}", obj));
        }

        static ZigConstAssign GetSingle(float value)
        {
            return
                float.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f32)") :
                float.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f32)") :
                float.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f32)") :
                new ZigConstAssign(string.Format("{0}", value), "f32");
        }

        static ZigConstAssign GetDouble(double value)
        {
            return
                double.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f64)") :
                double.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f64)") :
                double.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f64)") :
                new ZigConstAssign(string.Format("{0}", value), "f64");
        }
    }

    internal struct TypeGenInfo
    {
        public readonly TypeDefinition def;
        public readonly string name;
        public readonly string @namespace;
        public readonly string fqn; // note: all fqn (fully qualified name)'s are unique

        public TypeGenInfo(MetadataReader mr, TypeDefinitionHandle handle)
        {
            this.def = mr.GetTypeDefinition(handle);
            this.name = mr.GetString(this.def.Name);
            this.@namespace = mr.GetString(this.def.Namespace);
            this.fqn = string.Format("{0}.{1}", this.@namespace, this.name);
        }
    }

    // Note: keeps insertion order (the reason is for predictable code generation)
    internal class TypeGenInfoSet : IEnumerable<TypeGenInfo>
    {
        private readonly List<TypeGenInfo> ordered_list;
        private readonly Dictionary<string, TypeGenInfo> fqn_map;

        public TypeGenInfoSet()
        {
            this.ordered_list = new List<TypeGenInfo>();
            this.fqn_map = new Dictionary<string, TypeGenInfo>();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new InvalidOperationException();
        }

        public IEnumerator<TypeGenInfo> GetEnumerator()
        {
            return this.ordered_list.GetEnumerator();
        }

        public TypeGenInfo this[string fqn]
        {
            get
            {
                return this.fqn_map[fqn];
            }
        }

        public bool TryLookup(string fqn, out TypeGenInfo info)
        {
            return this.fqn_map.TryGetValue(fqn, out info);
        }

        public void Add(TypeGenInfo info)
        {
            this.ordered_list.Add(info);
            this.fqn_map.Add(info.fqn, info);
        }

        public void addOrVerifyEqual(TypeGenInfo info)
        {
            if (this.fqn_map.TryGetValue(info.fqn, out TypeGenInfo other))
            {
                if (!info.Equals(other))
                {
                    throw new InvalidDataException(string.Format(
                        "found 2 types with the same fully-qualified-name '{0}' that are not equal",
                        info.fqn));
                }
            }
            else
            {
                this.Add(info);
            }
        }

        public bool contains(TypeGenInfo info)
        {
            return this.fqn_map.ContainsKey(info.fqn);
        }
    }

    internal struct ZigConstAssign
    {
        public readonly string literal;
        public readonly string? optional_type;

        public ZigConstAssign(string literal, string? optional_type = null)
        {
            this.literal = literal;
            this.optional_type = optional_type;
        }
    }

    internal enum TypeVisibility
    {
        not_public,
        @public,
        nested_public,
        nested_private,
        nested_fam_and_assem,
        nested_assembly,
        nested_family,
        nested_fam_or_assem,
    }

    internal enum TypeLayout2
    {
        @auto,
        sequential,
        @explicit,
    }

    internal enum TypeClassSemantics
    {
        @class,
        @interface,
    }

    internal struct DecodedTypeAttributes
    {
        public readonly TypeVisibility visibility;
        public readonly TypeLayout2 layout;
        public readonly TypeClassSemantics class_semantics;
        public readonly bool is_abstract;
        public readonly bool is_sealed;

        public DecodedTypeAttributes(TypeAttributes attrs)
        {
            TypeAttributes visibility_attr = attrs & TypeAttributes.VisibilityMask;
            this.visibility = visibility_attr switch
            {
                TypeAttributes.NotPublic => TypeVisibility.not_public,
                TypeAttributes.Public => TypeVisibility.@public,
                TypeAttributes.NestedPublic => TypeVisibility.nested_public,
                TypeAttributes.NestedPrivate => TypeVisibility.nested_private,
                TypeAttributes.NestedFamANDAssem => TypeVisibility.nested_fam_and_assem,
                TypeAttributes.NestedAssembly => TypeVisibility.nested_assembly,
                TypeAttributes.NestedFamily => TypeVisibility.nested_family,
                TypeAttributes.NestedFamORAssem => TypeVisibility.nested_fam_or_assem,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute visibility {0}", visibility_attr)),
            };
            TypeAttributes layout_attr = attrs & TypeAttributes.LayoutMask;
            this.layout = layout_attr switch
            {
                TypeAttributes.AutoLayout => TypeLayout2.@auto,
                TypeAttributes.SequentialLayout => TypeLayout2.sequential,
                TypeAttributes.ExplicitLayout => TypeLayout2.@explicit,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute layout {0}", layout_attr)),
            };
            TypeAttributes class_semantics_attr = attrs & TypeAttributes.ClassSemanticsMask;
            this.class_semantics = class_semantics_attr switch
            {
                TypeAttributes.Class => TypeClassSemantics.@class,
                TypeAttributes.Interface => TypeClassSemantics.@interface,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute class semantics {0}", class_semantics_attr)),
            };
            this.is_abstract = (attrs & TypeAttributes.Abstract) != 0;
            this.is_sealed = (attrs & TypeAttributes.Sealed) != 0;
        }

        public override string ToString()
        {
            return string.Format(
                "Visibility={0} Layout={1} ClassSemantics={2} Abstract={3} Sealed={4}",
                this.visibility,
                this.layout,
                this.class_semantics,
                this.is_abstract,
                this.is_sealed);
        }
    }

    internal static class ZigLanguageData
    {
        public static readonly string[] keywords = new string[]
        {
            "align",
            "allowzero",
            "and",
            "anyframe",
            "anytype",
            "asm",
            "async",
            "await",
            "break",
            "callconv",
            "catch",
            "comptime",
            "const",
            "continue",
            "defer",
            "else",
            "enum",
            "errdefer",
            "error",
            "export",
            "extern",
            "false",
            "fn",
            "for",
            "if",
            "inline",
            "noalias",
            "nosuspend",
            "noinline",
            "null",
            "opaque",
            "or",
            "orelse",
            "packed",
            "pub",
            "resume",
            "return",
            "linksection",
            "struct",
            "suspend",
            "switch",
            "test",
            "threadlocal",
            "true",
            "try",
            "undefined",
            "union",
            "unreachable",
            "usingnamespace",
            "var",
            "volatile",
            "while",
        };
    }

    internal static class KnownIssues
    {
        // https://github.com/microsoft/CsWin32/issues/31
        internal static readonly HashSet<string> no_namespace_type_conflicts = new HashSet<string>
        {
            "_Anonymous_e__Union",
            "_Anonymous_e__Struct",
            "_IPv4_e__Struct",
            "_IPv4Transmit_e__Struct",
            "_IPv4Receive_e__Struct",
            "_IPv6Transmit_e__Struct",
            "_IPv6Receive_e__Struct",
            "_Supported_e__Struct",
            "_IPv4AH_e__Struct",
            "_IPv4ESP_e__Struct",
            "_IPv6_e__Struct",
            "_mod_vals_e__Union",
            "_FacialFeatures_e__Struct",
            "_Iris_e__Struct",
            "_Specific_e__Union",
            "_Fingerprint_e__Struct",
            "_EnrollmentRequirements_e__Struct",
            "_Voice_e__Struct",
            "_OpaqueEngineData_e__Struct",
            "_Parameters_e__Union",
            "_u_e__Struct",
            "_Anonymous1_e__Struct",
            "_Anonymous2_e__Struct",
            "_Data_e__Union",
            "_Flags_e__Union",
            "_Anonymous1_e__Union",
            "_Anonymous2_e__Union",
            "_Anonymous3_e__Struct",
            "_Anonymous3_e__Union",
            "_Flags_e__Struct",
            "_N_e__Union",
            "_Name_e__Struct",
            "_Sym_e__Struct",
            "_File_e__Struct",
            "_Section_e__Struct",
            "_CRC_e__Struct",
            "_u1_e__Union",
            "_u_e__Union",
            "_HighWord_e__Union",
            "_Bytes_e__Struct",
            "_Bits_e__Struct",
            "_Misc_e__Union",
            "_Values_e__Union",
            "_Value_e__Union",
            "_value_e__Union",
            "_Anonymous4_e__Union",
            "_Anonymous5_e__Union",
            "_Anonymous6_e__Union",
            "_Anonymous7_e__Union",
            "_Anonymous8_e__Union",
            "_MftWritesUserLevel_e__Struct",
            "_Mft2WritesUserLevel_e__Struct",
            "_BitmapWritesUserLevel_e__Struct",
            "_MftBitmapWritesUserLevel_e__Struct",
            "_Allocate_e__Struct",
            "_Version1_e__Struct",
            "_Version2_e__Struct",
            "_Version3_e__Struct",
            "_Class_e__Struct",
            "_VersionDetail_e__Struct",
            "_data_e__Union",
            "_bmAttributes_e__Union",
            "_FetchData_e__Struct",
            "_Data_e__Struct",
            "_Range_e__Struct",
            "_NotRange_e__Struct",
            "_Type_e__Union",
            "_MiniFilter_e__Struct",
            "_LegacyFilter_e__Struct",
            "_Header_e__Union",
            "_Version_e__Union",
            "_Timecode_e__Struct",
            "_RawAVC_e__Struct",
            "_arguments_e__Union",
            "_Info_e__Union",
            "_s_e__Struct",
            "_Attribute_e__Union",
            "_Target_e__Struct",
            "_Bounds_e__Union",
            "_Metrics_e__Union",
            "_lfFont_e__Union",
            "_Handles_e__Union",
            "_DeviceInterface_e__Struct",
            "_DeviceHandle_e__Struct",
            "_DeviceInstance_e__Struct",
            "_Error_e__Struct",
            "_S_un_e__Union",
            "_Event_e__Struct",
            "_irdaAttribute_e__Union",
            "_irdaAttribOctetSeq_e__Struct",
            "_irdaAttribUsrStr_e__Struct",
            "_out_e__Struct",
        };
    }
}
