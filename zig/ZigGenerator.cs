#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable SA1306 // Field names should begin with lower-case letter
namespace ZigWin32
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Reflection.Metadata;
    using System.Reflection.PortableExecutable;
    using System.Text;
    using System.Threading;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    public class ZigGenerator
    {
        private const string WindowsWin32NamespacePrefix = "Windows.Win32.";
        private const string AutogeneratedMessage = "//! NOTE: this source file is autogenerated, DO NOT MODIFY";
        private const string Win32Zig = @"
pub const api = @import(""win32/api.zig"");
// TODO glue? header?

test """" {
    @import(""std"").testing.refAllDecls(@This());
}
";

        private readonly MetadataReader mr;
        private readonly CancellationToken cancel_token;

        private ZigGenerator(MetadataReader mr, CancellationToken cancel_token)
        {
            this.mr = mr;
            this.cancel_token = cancel_token;
        }

        // returns: the number of apis generated
        public static uint Generate(Stream metadata_stream, string out_dir, CancellationToken cancel_token)
        {
            using PEReader pe_reader = new PEReader(metadata_stream);
            MetadataReader mr = pe_reader.GetMetadataReader();
            ZigGenerator generator = new ZigGenerator(mr, cancel_token);
            Api[] apis = mr.TypeDefinitions.Select(mr.GetTypeDefinition)
                .Where(td => mr.StringComparer.Equals(td.Name, "Apis"))
                .Select(td => new Api(mr, td)).ToArray();
            {
                var win32_filename = Path.Combine(out_dir, "win32.zig");
                using var file_stream = new FileStream(win32_filename, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                out_file.Write(Win32Zig);
            }

            string win32_dir = Path.Combine(out_dir, "win32");
            Directory.CreateDirectory(win32_dir);

            string api_dir = Path.Combine(win32_dir, "api");
            Directory.CreateDirectory(api_dir);

            foreach (Api api in apis)
            {
                string filepath = Path.Combine(api_dir, api.base_filename);
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                Console.WriteLine("Api: {0}", api.name);
                generator.GenerateApi(out_file, api);
            }

            {
                string filepath = Path.Combine(win32_dir, "api.zig");
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                foreach (Api api in apis)
                {
                    out_file.WriteLine(@"pub const {0} = @import(""api/{1}"");", api.name_lower, api.base_filename);
                }

                out_file.WriteLine(@"test """" {{");
                out_file.WriteLine(@"    const api_count = {0};", apis.Length);
                out_file.WriteLine(@"    @setEvalBranchQuota(api_count);");
                out_file.WriteLine(@"    @import(""std"").testing.refAllDecls(@This());");
                out_file.WriteLine(@"}}");
            }

            return (uint)apis.Length;
        }

        private void GenerateApi(StreamWriter out_file, Api api)
        {
            out_file.WriteLine(AutogeneratedMessage);

            uint const_count = 0;
            foreach (FieldDefinitionHandle field_def in api.type_def.GetFields())
            {
                this.cancel_token.ThrowIfCancellationRequested();
                this.GenerateConstant(out_file, field_def);
                const_count += 1;
            }

            out_file.WriteLine("test \"\" {{");
            out_file.WriteLine("    const constant_export_count = {0};", const_count);
            out_file.WriteLine("    @setEvalBranchQuota(constant_export_count + 2); // TODO: why do I need these extra 2?");
            out_file.WriteLine("    @import(\"std\").testing.refAllDecls(@This());");
            out_file.WriteLine("}}");
        }

        private void GenerateConstant(StreamWriter out_file, FieldDefinitionHandle fieldDefHandle)
        {
            FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);

            FieldAttributes expected = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal | FieldAttributes.HasDefault;
            if (fieldDef.Attributes != expected)
            {
                throw new InvalidOperationException(string.Format(
                    "Expected Constant FieldDefinition to have these attributes '{0}' but got '{1}'", expected, fieldDef.Attributes));
            }

            Debug.Assert(fieldDef.GetOffset() == -1, "Constant unexpectedly has an offset");
            Debug.Assert(fieldDef.GetRelativeVirtualAddress() == 0, "Constant unexpectedly has non-zero virtual address");

            // TODO: what is this signature?
            byte[] signature = this.mr.GetBlobBytes(fieldDef.Signature);

            // out_file.WriteLine("// signature (TODO: what is this for?) {0} bytes: {1}", signature.Length, BitConverter.ToString(signature));

            // TODO: handle custom attributes
            // TODO: what is fieldDef.GetMarshallingDescriptor?
            foreach (CustomAttributeHandle attrHandle in fieldDef.GetCustomAttributes())
            {
                var attr = this.mr.GetCustomAttribute(attrHandle);

                // TODO: what to do with this?
                /*
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(GuidAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    guid = Guid.Parse((string)args.FixedArguments[0].Value!);
                }
                */
            }

            // NOTE: fieldDef.GetDeclaringType returns the type that contains the Constant
            //       I will probably use this to know where to put the constant but it has nothing
            //       to do with the type of the constant.
            // TypeGenInfo containingTypeInfo = this.GetTypeGenInfo(fieldDef.GetDeclaringType());
            string name = this.mr.GetString(fieldDef.Name);
            Constant constant = this.mr.GetConstant(fieldDef.GetDefaultValue());
            ZigConstAssign assign = constant.ToZigConstAssign(this.mr);
            if (assign.optional_type == null)
            {
                out_file.WriteLine("pub const {0} = {1};", name, assign.literal);
            }
            else
            {
                out_file.WriteLine("pub const {0} : {1} = {2};", name, assign.optional_type, assign.literal);
            }
        }

        private bool IsAttribute(CustomAttribute attribute, string ns, string name)
        {
            StringHandle actualNamespace, actualName;
            if (attribute.Constructor.Kind == HandleKind.MemberReference)
            {
                MemberReference memberReference = this.mr.GetMemberReference((MemberReferenceHandle)attribute.Constructor);
                TypeReference parentRef = this.mr.GetTypeReference((TypeReferenceHandle)memberReference.Parent);
                actualNamespace = parentRef.Namespace;
                actualName = parentRef.Name;
            }
            else if (attribute.Constructor.Kind == HandleKind.MethodDefinition)
            {
                MethodDefinition methodDef = this.mr.GetMethodDefinition((MethodDefinitionHandle)attribute.Constructor);
                TypeDefinition typeDef = this.mr.GetTypeDefinition(methodDef.GetDeclaringType());
                actualNamespace = typeDef.Namespace;
                actualName = typeDef.Name;
            }
            else
            {
                throw new NotSupportedException("Unsupported attribute constructor kind: " + attribute.Constructor.Kind);
            }

            return this.mr.StringComparer.Equals(actualName, name) && this.mr.StringComparer.Equals(actualNamespace, ns);
        }

        private struct Api
        {
            public readonly TypeDefinition type_def;
            public readonly string name;
            public readonly string name_lower;
            public readonly string base_filename;

            public Api(MetadataReader mr, TypeDefinition type_def)
            {
                this.type_def = type_def;
                string api_namespace = mr.GetString(type_def.Namespace);
                Debug.Assert(
                    api_namespace.StartsWith(WindowsWin32NamespacePrefix, StringComparison.Ordinal),
                    "an Apis Type was not in the Windows.Win32 namespace");
                this.name = api_namespace.Substring(WindowsWin32NamespacePrefix.Length);
                this.name_lower = this.name.ToLowerInvariant();
                this.base_filename = this.name_lower + ".zig";
            }
        }
    }

    internal static class GenUtil
    {
        public static ZigConstAssign ToZigConstAssign(this Constant constant, MetadataReader mr)
        {
            return constant.TypeCode.ToZigConstAssign(mr.GetBlobReader(constant.Value));
        }

        public static ZigConstAssign ToZigConstAssign(this ConstantTypeCode typeCode, BlobReader blobReader)
        {
            return typeCode switch
            {
#pragma warning disable SA1025 // Code should not contain multiple whitespace in a row
                ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? new ZigConstAssign("true") : new ZigConstAssign("false"),
                ConstantTypeCode.Char    => new ZigConstAssign(string.Format("'{0}'", blobReader.ReadChar())),
                ConstantTypeCode.SByte   => new ZigConstAssign(string.Format("{0}", blobReader.ReadSByte()),  "i8"),
                ConstantTypeCode.Byte    => new ZigConstAssign(string.Format("{0}", blobReader.ReadByte()),   "u8"),
                ConstantTypeCode.Int16   => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt16()),  "i16"),
                ConstantTypeCode.UInt16  => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt16()), "u16"),
                ConstantTypeCode.Int32   => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt32()),  "i32"),
                ConstantTypeCode.UInt32  => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt32()), "u32"),
                ConstantTypeCode.Int64   => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt64()),  "i64"),
                ConstantTypeCode.UInt64  => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt64()), "u64"),
                ConstantTypeCode.Single  => GetSingle(blobReader.ReadSingle()),
                ConstantTypeCode.Double  => GetDouble(blobReader.ReadDouble()),
                ConstantTypeCode.String  => GetString(blobReader.ReadConstant(ConstantTypeCode.String)),
                ConstantTypeCode.NullReference => new ZigConstAssign("null"),
#pragma warning restore SA1025 // Code should not contain multiple whitespace in a row
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + typeCode),
            };
            static ZigConstAssign GetString(object? obj)
            {
                return obj is string value ?
                    new ZigConstAssign(string.Format("\"{0}\"", value)) :
                    throw new Exception(string.Format("String constant is not a string? it is: {0}", obj));
            }

            static ZigConstAssign GetSingle(float value)
            {
                return
                    float.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f32)") :
                    float.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f32)") :
                    float.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f32)") :
                    new ZigConstAssign(string.Format("{0}", value), "f32");
            }

            static ZigConstAssign GetDouble(double value)
            {
                return
                    double.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f64)") :
                    double.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f64)") :
                    double.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f64)") :
                    new ZigConstAssign(string.Format("{0}", value), "f64");
            }
        }
    }

    internal struct TypeGenInfo
    {
        public readonly TypeDefinition def;
        private readonly string name;

        public TypeGenInfo(MetadataReader mr, TypeDefinitionHandle handle)
        {
            this.def = mr.GetTypeDefinition(handle);
            this.name = mr.GetString(this.def.Name);
        }

        public string Zig
        {
            get { return this.name; }
        }
    }

    internal struct ZigConstAssign
    {
        public readonly string literal;
        public readonly string? optional_type;

        public ZigConstAssign(string literal, string? optional_type = null)
        {
            this.literal = literal;
            this.optional_type = optional_type;
        }
    }
}
