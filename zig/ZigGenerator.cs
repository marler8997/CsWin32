using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text;
using System.Threading;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

public static partial class ZigWin32
{
    const string WindowsWin32NamespacePrefix = "Windows.Win32.";
    static readonly Dictionary<string, string> zig_keyword_id_map = new Dictionary<string, string>();

    static ZigWin32()
    {
        foreach (string keyword in zig_keywords)
        {
            zig_keyword_id_map.Add(keyword, string.Format("@\"{0}\"", keyword));
        }
    }

    public class ZigGenerator
    {
        const string AutogeneratedMessage = "//! NOTE: this source file is autogenerated, DO NOT MODIFY";
        const string Win32Zig = @"
pub const api = @import(""win32/api.zig"");
// TODO glue? header?

test """" {
    @import(""std"").testing.refAllDecls(@This());
}
";

        const string Win32GlueZig = @"

pub const Guid = extern struct {
    bytes: [16]u8,
};

test """" {
    @import(""std"").testing.refAllDecls(@This());
}
";

        readonly MetadataReader mr;
        readonly CancellationToken cancel_token;
        readonly Dictionary<string, Api> api_namespace_map = new Dictionary<string, Api>();
        readonly Dictionary<TypeDefinitionHandle, TypeGenInfo> type_map = new Dictionary<TypeDefinitionHandle, TypeGenInfo>();
        readonly TypeRefDecoder type_ref_decoder;

        ZigGenerator(MetadataReader mr, CancellationToken cancel_token)
        {
            this.mr = mr;
            this.cancel_token = cancel_token;

            // ---------------------------------------------------------------
            // Scan all types and sort into the api they belong to
            // ---------------------------------------------------------------
            List<TypeDefinitionHandle> nested_types = new List<TypeDefinitionHandle>();
            foreach (TypeDefinitionHandle type_def_handle in this.mr.TypeDefinitions)
            {
                TypeDefinition type_def = mr.GetTypeDefinition(type_def_handle);

                // skip nested types until we get all the non-nested types, this is because
                // we need to be able to look up the enclosing type to get all the info we need
                if (type_def.IsNested)
                {
                    nested_types.Add(type_def_handle);
                    continue;
                }
                TypeGenInfo type_info = TypeGenInfo.CreateNotNested(mr, type_def);
                this.type_map.Add(type_def_handle, type_info);

                if (type_info.type_namespace.Length == 0)
                {
                    Debug.Assert(type_info.name == "<Module>", "found a type without a namespace that is not nested and not '<Module>'");
                    continue;
                }

                Api? api;
                if (!this.api_namespace_map.TryGetValue(type_info.api_namespace, out api))
                {
                    api = new Api(type_info.api_namespace);
                    this.api_namespace_map.Add(type_info.api_namespace, api);
                }

                if (type_info.name == "Apis")
                {
                    // NOTE: The "Apis" type is a specially-named type reserved to contain all the constant
                    // and function declarations for an api.
                    Debug.Assert(api.constants == null, "multiple Apis types in the same namespace");
                    api.constants = type_info.def.GetFields();
                    api.funcs = type_info.def.GetMethods();
                }
                else
                {
                    api.addTopLevelType(type_info);
                }
            }

            // ---------------------------------------------------------------
            // Now go back through and create objects for the nested types
            // ---------------------------------------------------------------
            for (uint pass = 1; ; pass++)
            {
                int save_length = nested_types.Count;
                Console.WriteLine("DEBUG: nested loop pass {0} (types left: {1})", pass, save_length);

                for (int i = nested_types.Count - 1; i >= 0; i--)
                {
                    TypeDefinitionHandle type_def_handle = nested_types[i];
                    TypeDefinition type_def = mr.GetTypeDefinition(type_def_handle);
                    Debug.Assert(type_def.IsNested, "codebug");
                    if (this.type_map.TryGetValue(type_def.GetDeclaringType(), out TypeGenInfo? enclosing_type))
                    {
                        TypeGenInfo type_info = TypeGenInfo.CreateNested(mr, type_def, enclosing_type);
                        this.type_map.Add(type_def_handle, type_info);
                        enclosing_type.addNestedType(type_info);
                        nested_types.RemoveAt(i);
                        i--;
                    }
                }

                if (nested_types.Count == 0)
                {
                    break;
                }

                if (save_length == nested_types.Count)
                {
                    throw new InvalidDataException(string.Format(
                        "found {0} nested types whose declaring type handle does not match any type definition handle",
                        nested_types.Count));
                }
            }

            this.type_ref_decoder = new TypeRefDecoder(this.api_namespace_map, this.type_map);
        }

        internal static void Generate(MetadataReader mr, string out_dir, CancellationToken cancel_token)
        {
            ZigGenerator generator = new ZigGenerator(mr, cancel_token);

            {
                var win32_filename = Path.Combine(out_dir, "win32.zig");
                using var file_stream = new FileStream(win32_filename, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                out_file.Write(Win32Zig);
            }

            string win32_dir = Path.Combine(out_dir, "win32");
            Directory.CreateDirectory(win32_dir);

            {
                var glue_filename = Path.Combine(win32_dir, "glue.zig");
                using var file_stream = new FileStream(glue_filename, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                out_file.Write(Win32GlueZig);
            }

            string api_dir = Path.Combine(win32_dir, "api");
            Directory.CreateDirectory(api_dir);

            foreach (Api api in generator.api_namespace_map.Values)
            {
                string filepath = Path.Combine(api_dir, api.base_filename);
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                Console.WriteLine("Api: {0}", api.name);
                generator.GenerateApi(out_file, api);
            }

            {
                string filepath = Path.Combine(win32_dir, "api.zig");
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                foreach (Api api in generator.api_namespace_map.Values)
                {
                    out_file.WriteLine(@"pub const {0} = @import(""api/{1}"");", api.name_lower, api.base_filename);
                }

                out_file.WriteLine(@"test """" {");
                out_file.WriteLine(@"    const api_count = {0};", generator.api_namespace_map.Count);
                out_file.WriteLine(@"    @setEvalBranchQuota(api_count);");
                out_file.WriteLine(@"    @import(""std"").testing.refAllDecls(@This());");
                out_file.WriteLine(@"}");
            }
        }

        void GenerateApi(StreamWriter out_file, Api api)
        {
            out_file.WriteLine(AutogeneratedMessage);
            out_file.WriteLine();
            out_file.WriteLine("//");
            out_file.WriteLine("// constants");
            out_file.WriteLine("//");
            uint const_count = 0;
            if (api.constants != null)
            {
                foreach (FieldDefinitionHandle field_def in api.constants)
                {
                    this.cancel_token.ThrowIfCancellationRequested();
                    this.GenerateConstant(out_file, field_def);
                    const_count += 1;
                }
            }
            out_file.WriteLine();
            out_file.WriteLine("//");
            out_file.WriteLine("// types");
            out_file.WriteLine("//");
            TypeGenInfoSet type_refs = new TypeGenInfoSet();
            uint type_count = 0;
            foreach (TypeGenInfo type_info in api.top_level_types)
            {
                this.cancel_token.ThrowIfCancellationRequested();
                this.GenerateType(out_file, type_refs, type_info);
                type_count += 1;
            }
            out_file.WriteLine();
            out_file.WriteLine("//");
            out_file.WriteLine("// functions");
            out_file.WriteLine("//");
            uint func_count = 0;
            if (api.funcs != null)
            {
                foreach (MethodDefinitionHandle func_handle in api.funcs)
                {
                    this.generateFunc(out_file, type_refs, func_handle);
                    func_count++;
                }
            }
            out_file.WriteLine();
            out_file.WriteLine("//");
            out_file.WriteLine("// type imports");
            out_file.WriteLine("//");
            uint type_import_count = 0;
            if (type_refs.contains_system_guid)
            {
                out_file.WriteLine("const Guid = @import(\"../glue.zig\").Guid;");
                type_import_count += 1;
            }
            foreach (TypeGenInfo type_ref in type_refs)
            {
                // this means a nested type was referenced such that the scope where it was
                // referenced did not contain the nested type. This will need to be handled
                // by qualifying the nested type with its enclosing types.
                if (type_ref.isNested())
                {
                    throw new NotImplementedException();
                }
                else if (!api.top_level_types.contains(type_ref))
                {
                    if (type_ref.type_namespace.Length == 0)
                    {
                        throw new InvalidOperationException();
                    }
                    Api import_api = this.api_namespace_map[type_ref.api_namespace];
                    out_file.WriteLine("const {0} = @import(\"{1}\").{0};", type_ref.name, import_api.base_filename);
                    type_import_count += 1;
                }
            }
            out_file.WriteLine();
            out_file.WriteLine("test \"\" {");
            out_file.WriteLine("    const constant_export_count = {0};", const_count);
            out_file.WriteLine("    const type_export_count = {0};", type_count);
            out_file.WriteLine("    const func_count = {0};", func_count);
            out_file.WriteLine("    const type_import_count = {0};", type_import_count);
            out_file.WriteLine("    @setEvalBranchQuota(constant_export_count + type_export_count + func_count + type_import_count + 2); // TODO: why do I need these extra 2?");
            out_file.WriteLine("    @import(\"std\").testing.refAllDecls(@This());");
            out_file.WriteLine("}");
        }

        void GenerateConstant(StreamWriter out_file, FieldDefinitionHandle fieldDefHandle)
        {
            FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);

            FieldAttributes expected = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal | FieldAttributes.HasDefault;
            if (fieldDef.Attributes != expected)
            {
                throw new InvalidOperationException(string.Format(
                    "Expected Constant FieldDefinition to have these attributes '{0}' but got '{1}'", expected, fieldDef.Attributes));
            }

            Debug.Assert(fieldDef.GetOffset() == -1, "Constant unexpectedly has an offset");
            Debug.Assert(fieldDef.GetRelativeVirtualAddress() == 0, "Constant unexpectedly has non-zero virtual address");

            // TODO: what is this signature?
            byte[] signature = this.mr.GetBlobBytes(fieldDef.Signature);

            // out_file.WriteLine("// signature (TODO: what is this for?) {0} bytes: {1}", signature.Length, BitConverter.ToString(signature));

            // TODO: handle custom attributes
            // TODO: what is fieldDef.GetMarshallingDescriptor?
            foreach (CustomAttributeHandle attrHandle in fieldDef.GetCustomAttributes())
            {
                var attr = this.mr.GetCustomAttribute(attrHandle);

                // TODO: what to do with this?
                /*
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(GuidAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    guid = Guid.Parse((string)args.FixedArguments[0].Value!);
                }
                */
            }

            string name = this.mr.GetString(fieldDef.Name);
            Constant constant = this.mr.GetConstant(fieldDef.GetDefaultValue());
            var assign = toZigConstAssign(constant, this.mr);
            if (assign.optional_type == null)
            {
                out_file.WriteLine("pub const {0} = {1};", name, assign.literal);
            }
            else
            {
                out_file.WriteLine("pub const {0} : {1} = {2};", name, assign.optional_type, assign.literal);
            }
        }

        void GenerateType(StreamWriter out_file, TypeGenInfoSet type_refs, TypeGenInfo type_info)
        {
            out_file.WriteLine("// --------------------------------------------------------");
            out_file.WriteLine("// Type: {0}", type_info.name);
            out_file.WriteLine("// Nested: {0}", type_info.def.IsNested);

            DecodedTypeAttributes attrs = new DecodedTypeAttributes(type_info.def.Attributes);

            out_file.WriteLine("// Attributes: {0}", attrs);

            TypeGenInfo? optional_declaring_type = null;
            if (type_info.def.IsNested)
            {
                TypeGenInfo declaring_type = this.type_map[type_info.def.GetDeclaringType()];
                optional_declaring_type = declaring_type;
                out_file.WriteLine("// DeclaringType: {0} (api namespace={1})", declaring_type.name, declaring_type.api_namespace);
            }
            else
            {
                Debug.Assert(type_info.def.GetDeclaringType().IsNil, "unexpected data");
                out_file.WriteLine("// DeclaringType: <null>");
            }

            /*
             * TODO: look at these Methods on TypeDefinition as well
            type_info.def.GetDeclarativeSecurityAttributes()
            public EventDefinitionHandleCollection GetEvents();
            public FieldDefinitionHandleCollection GetFields();
            public GenericParameterHandleCollection GetGenericParameters();
            public InterfaceImplementationHandleCollection GetInterfaceImplementations();
            public TypeLayout GetLayout();
            public MethodImplementationHandleCollection GetMethodImplementations();
            public MethodDefinitionHandleCollection GetMethods();
            // Summary:
            //     Returns an array of types nested in the specified type.
            // Returns:
            //     An immutable array of type definition handles that represent types nested in
            //     the specified type.
            public ImmutableArray<TypeDefinitionHandle> GetNestedTypes();
            public PropertyDefinitionHandleCollection GetProperties();
            */

            string? skip_because = null;
            if (type_info.def.IsNested)
            {
                skip_because = "its a nested type";
            }
            else if (attrs.is_abstract)
            {
                skip_because = "its an abstract type";
            }
            else if (attrs.visibility != TypeVisibility.@public)
            {
                skip_because = "its a non-public type";
            }
            else if (!attrs.is_sealed)
            {
                skip_because = "its a non-sealed type";
            }
            else if (attrs.layout == TypeLayout2.@explicit)
            {
                skip_because = "it has an explicit layout";
            }
            else if (attrs.layout == TypeLayout2.@auto)
            {
                skip_because = "it has an 'auto' layout";
            }
            else if (attrs.class_semantics == TypeClassSemantics.@interface)
            {
                skip_because = "it is an interface type";
            }

            if (skip_because != null)
            {
                out_file.WriteLine("// not generate proper code for this type because {0}", skip_because);
                if (type_info.nestedTypeCount() != 0)
                {
                    out_file.WriteLine("// WARNING: this type we are skipping has nested types!");
                }
                out_file.WriteLine("pub const {0} = *opaque{{}};", type_info.name);
                return;
            }

            string? optional_type_guid = null;
            bool is_native_typedef = false;

            foreach (CustomAttributeHandle attr_handle in type_info.def.GetCustomAttributes())
            {
                BasicTypeAttr attr = this.decodeBasicTypeAttr(this.mr.GetCustomAttribute(attr_handle));
                if (attr is BasicTypeAttr.Guid guid_attr)
                {
                    optional_type_guid = guid_attr.value;
                }
                else if (attr is BasicTypeAttr.RaiiFree)
                {
                    Console.WriteLine("RaiiFree: {0}", type_info.name);

                    // TODO: what to do with this?
                }
                else if (attr is BasicTypeAttr.NativeTypedef)
                {
                    is_native_typedef = true;
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }

            if (is_native_typedef)
            {
                if (type_info.def.GetFields().Count != 1)
                {
                    throw new InvalidDataException(string.Format("native typedef '{0}' has fields?", type_info.name));
                }
                FieldDefinition target_def = this.mr.GetFieldDefinition(type_info.def.GetFields().First());
                string target_def_zig = addTypeRef(TypeRefScope.init(type_refs, type_info), target_def.DecodeSignature(this.type_ref_decoder, null));
                out_file.WriteLine("pub const {0} = {1};", escapeZigId(type_info.name), target_def_zig);
                assertData(type_info.nestedTypeCount() == 0);
                return;
            }

            out_file.WriteLine("// TODO: I think this is a struct, but not sure at this point, assuming it is for now");
            if (type_info.def.GetFields().Count == 0)
            {
                out_file.WriteLine(
                    "pub const {0} = opaque {{ }}; // a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque",
                    type_info.name);
                assertTemp(type_info.nestedTypeCount() == 0);
                return;
            }
            else
            {
                out_file.WriteLine("pub const {0} = extern struct {{", type_info.name);
                foreach (FieldDefinitionHandle field_def_handle in type_info.def.GetFields())
                {
                    FieldDefinition field_def = this.mr.GetFieldDefinition(field_def_handle);
                    string field_type_zig = addTypeRef(TypeRefScope.init(type_refs, type_info), field_def.DecodeSignature(this.type_ref_decoder, null));
                    out_file.WriteLine("    {0}: {1},", escapeZigId(this.mr.GetString(field_def.Name)), field_type_zig);
                }

                foreach (TypeGenInfo nested_type in type_info.nestedTypes())
                {
                    out_file.WriteLine("    pub const {0} = *opaque{{}}; // TODO: generate this nested type", nested_type.name);
                }

                out_file.WriteLine("};");
            }
        }

        BasicTypeAttr decodeBasicTypeAttr(CustomAttribute attr)
        {
            NamespaceAndName attr_name = getAttrTypeName(this.mr, attr);
            CustomAttributeValue<CustomAttrType> attr_args = attr.DecodeValue(CustomAttrDecoder.Instance);
            if (attr_name.Equals("System.Runtime.InteropServices", "GuidAttribute"))
            {
                enforceAttrFixedArgCount(attr_name, attr_args, 1);
                enforceAttrNamedArgCount(attr_name, attr_args, 0);
                return new BasicTypeAttr.Guid(attrFixedArgAsString(attr_args.FixedArguments[0]));
            }
            if (attr_name.Equals("Windows.Win32.Interop", "RAIIFreeAttribute"))
            {
                enforceAttrFixedArgCount(attr_name, attr_args, 1);
                enforceAttrNamedArgCount(attr_name, attr_args, 0);
                return new BasicTypeAttr.RaiiFree(attrFixedArgAsString(attr_args.FixedArguments[0]));
            }
            if (attr_name.Equals("Windows.Win32.Interop", "NativeTypedefAttribute"))
            {
                enforceAttrFixedArgCount(attr_name, attr_args, 0);
                enforceAttrNamedArgCount(attr_name, attr_args, 0);
                return new BasicTypeAttr.NativeTypedef();
            }
            throw new NotImplementedException(string.Format("uhandled custom attr \"{0}\", \"{1}\"", attr_name.@namespace, attr_name.name));
        }

        static NamespaceAndName getAttrTypeName(MetadataReader mr, CustomAttribute attr)
        {
            if (attr.Constructor.Kind == HandleKind.MemberReference)
            {
                MemberReference member_ref = mr.GetMemberReference((MemberReferenceHandle)attr.Constructor);
                TypeReference parent_ref = mr.GetTypeReference((TypeReferenceHandle)member_ref.Parent);
                return new NamespaceAndName(mr.GetString(parent_ref.Namespace), mr.GetString(parent_ref.Name));
            }

            if (attr.Constructor.Kind == HandleKind.MethodDefinition)
            {
                MethodDefinition method_def = mr.GetMethodDefinition((MethodDefinitionHandle)attr.Constructor);
                TypeDefinition type_def = mr.GetTypeDefinition(method_def.GetDeclaringType());
                return new NamespaceAndName(mr.GetString(type_def.Namespace), mr.GetString(type_def.Name));
            }

            throw new InvalidDataException("Unsupported attribute constructor kind: " + attr.Constructor.Kind);
        }

        void generateFunc(StreamWriter out_file, TypeGenInfoSet type_refs, MethodDefinitionHandle func_handle)
        {
            MethodDefinition func_def = this.mr.GetMethodDefinition(func_handle);
            string func_name = this.mr.GetString(func_def.Name);

            // Looks like right now all the functions have these same attributes
            DecodedMethodAttributes decoded_attrs = new DecodedMethodAttributes(func_def.Attributes);
            assertData(decoded_attrs.member_access == MemberAccess.@public);
            assertData(decoded_attrs.is_static);
            assertData(!decoded_attrs.is_final);
            assertData(!decoded_attrs.is_virtual);
            assertData(!decoded_attrs.is_abstract);
            assertData(!decoded_attrs.pinvoke_impl);
            assertData(decoded_attrs.hide_by_sig);
            assertData(!decoded_attrs.new_slot);
            assertData(!decoded_attrs.special_name);
            assertData(!decoded_attrs.check_access_on_override);
            out_file.WriteLine();
            out_file.WriteLine("pub extern \"todo\" fn {0}(", func_name);

            MethodSignature<TypeRef> method_sig = func_def.DecodeSignature(this.type_ref_decoder, null);

            int next_expected_sequence_number = 1;
            foreach (ParameterHandle param_handle in func_def.GetParameters())
            {
                Parameter param = this.mr.GetParameter(param_handle);
                if (param.SequenceNumber == 0)
                {
                    // this is the return parameter
                    continue;
                }
                assertData(param.SequenceNumber == next_expected_sequence_number, "parameters were not ordered");
                next_expected_sequence_number++;

                // TODO: how do I get the type?  via the sequence number?
                // TODO: handle param.Attributes
                // TODO: handle param.GetCustomAttributes()
                // TODO: handle param.GetDefaultValue();
                // TODO: handle param.GetMarshallingDescriptor();
                string param_name = this.mr.GetString(param.Name);
                assertData(param_name.Length > 0);

                var param_type = method_sig.ParameterTypes[param.SequenceNumber - 1];
                var zig_type = addTypeRef(TypeRefScope.init(type_refs, null), param_type);
                out_file.WriteLine("    {0}: {1},", escapeZigId(param_name), zig_type);
            }
            out_file.WriteLine(
                ") callconv(@import(\"std\").os.windows.WINAPI) {0};",
                addTypeRef(TypeRefScope.init(type_refs, null), method_sig.ReturnType));
        }
    }

    // assert that an assumption about the win32metdata winmd data is true
    static void assertData(bool assumption, string? optional_msg = null)
    {
        if (!assumption)
        {
            string suffix = (optional_msg == null) ? "" : (": " + optional_msg);
            throw new InvalidDataException("an assumption about the win32metadata winmd data was violated" + suffix);
        }
    }

    // assert that something is true temporarily
    static void assertTemp(bool cond)
    {
        if (!cond)
        {
            throw new InvalidDataException("an assertTemp is false");
        }
    }

    struct NamespaceAndName
    {
        public readonly string @namespace;
        public readonly string name;

        public NamespaceAndName(string @namespace, string name)
        {
            this.@namespace = @namespace;
            this.name = name;
        }

        public bool Equals(string @namespace, string name)
        {
            return this.name == name && this.@namespace == @namespace;
        }
    }

    class Api
    {
        public readonly string name;
        public readonly string name_lower;
        public readonly string base_filename;
        public readonly TypeGenInfoSet top_level_types = new TypeGenInfoSet();
        public readonly Dictionary<string, string> type_name_fqn_map = new Dictionary<string, string>();
        public FieldDefinitionHandleCollection? constants;
        public MethodDefinitionHandleCollection? funcs;
        public readonly HashSet<TypeGenInfo> type_imports = new HashSet<TypeGenInfo>();

        public Api(string @namespace)
        {
            if (!@namespace.StartsWith(WindowsWin32NamespacePrefix, StringComparison.Ordinal))
            {
                throw new InvalidDataException(string.Format(
                    "Unexpected namespace '{0}', expected it to start with '{1}'",
                    @namespace,
                    WindowsWin32NamespacePrefix));
            }
            this.name = @namespace.Substring(WindowsWin32NamespacePrefix.Length);
            this.name_lower = this.name.ToLowerInvariant();
            this.base_filename = this.name_lower + ".zig";
        }

        public void addTopLevelType(TypeGenInfo type_info)
        {
            Debug.Assert(!type_info.isNested(), "codebug");
            this.top_level_types.Add(type_info);
            this.type_name_fqn_map.Add(type_info.name, type_info.fqn);
        }
    }

    struct TypeRefScope
    {
        public readonly TypeGenInfoSet module_type_refs;
        public readonly TypeGenInfo? optional_type_context;

        private TypeRefScope(TypeGenInfoSet module_type_refs, TypeGenInfo? optional_type_context)
        {
            this.module_type_refs = module_type_refs;
            this.optional_type_context = optional_type_context;
        }

        public static TypeRefScope init(TypeGenInfoSet module_type_refs, TypeGenInfo? optional_type_context)
        {
            return new TypeRefScope(module_type_refs, optional_type_context);
        }

        public bool addTypeRef(TypeGenInfo info)
        {
            if (info.isNested())
            {
                if (this.optional_type_context != null && this.optional_type_context.hasNestedTypeInScope(info))
                {
                    return false; // no type ref needed
                }
                throw new NotImplementedException();
            }
            else
            {
                return this.module_type_refs.addOrVerifyEqual(info);
            }
        }
    }

    // I've purposely combined adding a type ref and creating the Zig
    // type string so I don't accidently generate a type without noting
    // that I'm referencing it.
    static string addTypeRef(TypeRefScope scope, TypeRef type_ref)
    {
        type_ref.addTypeRefs(scope);
        StringBuilder builder = new StringBuilder();
        type_ref.formatZigType(builder, DepthContext.top_level);
        return builder.ToString();
    }

    static string escapeZigId(string id)
    {
        string? zig_id;
        if (zig_keyword_id_map.TryGetValue(id, out zig_id))
        {
            return zig_id;
        }
        return id;
    }

    static ZigConstAssign toZigConstAssign(Constant constant, MetadataReader mr)
    {
        return toZigConstAssignImpl(constant.TypeCode, mr.GetBlobReader(constant.Value));
    }

    static ZigConstAssign toZigConstAssignImpl(ConstantTypeCode typeCode, BlobReader blobReader)
    {
        return typeCode switch
        {
            ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? new ZigConstAssign("true") : new ZigConstAssign("false"),
            ConstantTypeCode.Char => new ZigConstAssign(string.Format("'{0}'", blobReader.ReadChar())),
            ConstantTypeCode.SByte => new ZigConstAssign(string.Format("{0}", blobReader.ReadSByte()), "i8"),
            ConstantTypeCode.Byte => new ZigConstAssign(string.Format("{0}", blobReader.ReadByte()), "u8"),
            ConstantTypeCode.Int16 => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt16()), "i16"),
            ConstantTypeCode.UInt16 => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt16()), "u16"),
            ConstantTypeCode.Int32 => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt32()), "i32"),
            ConstantTypeCode.UInt32 => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt32()), "u32"),
            ConstantTypeCode.Int64 => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt64()), "i64"),
            ConstantTypeCode.UInt64 => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt64()), "u64"),
            ConstantTypeCode.Single => GetSingle(blobReader.ReadSingle()),
            ConstantTypeCode.Double => GetDouble(blobReader.ReadDouble()),
            ConstantTypeCode.String => GetString(blobReader.ReadConstant(ConstantTypeCode.String)),
            ConstantTypeCode.NullReference => new ZigConstAssign("null"),
            _ => throw new NotSupportedException("ConstantTypeCode not supported: " + typeCode),
        };
        static ZigConstAssign GetString(object? obj)
        {
            return obj is string value ?
                new ZigConstAssign(string.Format("\"{0}\"", value)) :
                throw new Exception(string.Format("String constant is not a string? it is: {0}", obj));
        }

        static ZigConstAssign GetSingle(float value)
        {
            return
                float.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f32)") :
                float.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f32)") :
                float.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f32)") :
                new ZigConstAssign(string.Format("{0}", value), "f32");
        }

        static ZigConstAssign GetDouble(double value)
        {
            return
                double.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f64)") :
                double.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f64)") :
                double.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f64)") :
                new ZigConstAssign(string.Format("{0}", value), "f64");
        }
    }

    class TypeGenInfo
    {
        public readonly TypeDefinition def;
        public readonly string name;
        public readonly string type_namespace; // note: this seems to always be empty for nested types
        public readonly string api_namespace;
        public readonly string fqn; // note: all fqn (fully qualified name)'s are unique

        private readonly TypeGenInfo? enclosing_type;
        private List<TypeGenInfo>? nested_types;

        TypeGenInfo(TypeDefinition def, string name, string type_namespace, string api_namespace, string fqn, TypeGenInfo? enclosing_type)
        {
            this.def = def;
            this.name = name;
            this.type_namespace = type_namespace;
            this.api_namespace = api_namespace;
            this.fqn = fqn;
            this.enclosing_type = enclosing_type;
        }

        public static TypeGenInfo CreateNotNested(MetadataReader mr, TypeDefinition def)
        {
            Debug.Assert(!def.IsNested, "CreateNotNested called for TypeDefinition that is nested");
            string name = mr.GetString(def.Name);
            string @namespace = mr.GetString(def.Namespace);
            string fqn = string.Format("{0}.{1}", @namespace, name);
            return new TypeGenInfo(
                def: def,
                name: name,
                type_namespace: @namespace,
                api_namespace: @namespace,
                fqn: fqn,
                enclosing_type: null);
        }

        public static TypeGenInfo CreateNested(MetadataReader mr, TypeDefinition def, TypeGenInfo enclosing_type)
        {
            Debug.Assert(def.IsNested, "CreateNested called for TypeDefinition that is not nested");
            string name = mr.GetString(def.Name);
            string @namespace = mr.GetString(def.Namespace);
            assertData(@namespace.Length == 0, "I thought all nested types had an empty namespace");
            string fqn = string.Format("{0}+{1}", enclosing_type.fqn, name);
            return new TypeGenInfo(
                def: def,
                name: name,
                type_namespace: @namespace,
                api_namespace: enclosing_type.api_namespace,
                fqn: fqn,
                enclosing_type: enclosing_type);
        }

        public bool isNested()
        {
            return this.enclosing_type != null;
        }

        public uint nestedTypeCount()
        {
            return (this.nested_types == null) ? 0 : (uint)this.nested_types.Count;
        }

        public IEnumerable<TypeGenInfo> nestedTypes()
        {
            return (this.nested_types == null) ? Enumerable.Empty<TypeGenInfo>() : this.nested_types;
        }

        public TypeGenInfo? tryGetNestedTypeByName(string name)
        {
            if (this.nested_types != null)
            {
                foreach (TypeGenInfo info in this.nested_types)
                {
                    if (info.name == name)
                    {
                        return info;
                    }
                }
            }
            return null;
        }

        public void addNestedType(TypeGenInfo type_info)
        {
            if (this.nested_types == null)
            {
                this.nested_types = new List<TypeGenInfo>();
            }
            else if (this.tryGetNestedTypeByName(type_info.name) != null)
            {
                throw new InvalidOperationException(string.Format("nested type '{0}' already exists in '{1}'", type_info.name, this.fqn));
            }
            this.nested_types.Add(type_info);
        }

        public TypeGenInfo getNestedTypeByName(string name) => this.tryGetNestedTypeByName(name) is TypeGenInfo info ? info :
                throw new ArgumentException(string.Format("type '{0}' does not have nested type '{1}'", this.fqn, name));

        public bool hasNestedTypeInScope(TypeGenInfo info)
        {
            Debug.Assert(info.isNested(), "codebug");
            if (this.nested_types != null)
            {
                foreach (TypeGenInfo nested_info in this.nested_types)
                {
                    if (object.ReferenceEquals(nested_info, info))
                    {
                        return true;
                    }
                }
            }
            return this.enclosing_type is TypeGenInfo e && e.hasNestedTypeInScope(info);
        }
    }

    // Note: keeps insertion order (the reason is for predictable code generation)
    class TypeGenInfoSet : IEnumerable<TypeGenInfo>
    {
        public bool contains_system_guid;
        readonly List<TypeGenInfo> ordered_list;
        readonly Dictionary<string, TypeGenInfo> fqn_map;

        public TypeGenInfoSet()
        {
            this.ordered_list = new List<TypeGenInfo>();
            this.fqn_map = new Dictionary<string, TypeGenInfo>();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new InvalidOperationException();
        }

        public IEnumerator<TypeGenInfo> GetEnumerator()
        {
            return this.ordered_list.GetEnumerator();
        }

        public TypeGenInfo this[string fqn]
        {
            get
            {
                return this.fqn_map[fqn];
            }
        }

        public void Add(TypeGenInfo info)
        {
            this.ordered_list.Add(info);
            this.fqn_map.Add(info.fqn, info);
        }

        public bool addOrVerifyEqual(TypeGenInfo info)
        {
            if (this.fqn_map.TryGetValue(info.fqn, out TypeGenInfo? other))
            {
                if (!object.ReferenceEquals(info, other))
                {
                    throw new InvalidDataException(string.Format(
                        "found 2 types with the same fully-qualified-name '{0}' that are not equal",
                        info.fqn));
                }
                return false; // already added
            }
            this.Add(info);
            return true; // newly added
        }

        public bool contains(TypeGenInfo info)
        {
            return this.fqn_map.ContainsKey(info.fqn);
        }
    }

    struct ZigConstAssign
    {
        public readonly string literal;
        public readonly string? optional_type;

        public ZigConstAssign(string literal, string? optional_type = null)
        {
            this.literal = literal;
            this.optional_type = optional_type;
        }
    }

    enum TypeVisibility
    {
        not_public,
        @public,
        nested_public,
        nested_private,
        nested_fam_and_assem,
        nested_assembly,
        nested_family,
        nested_fam_or_assem,
    }

    enum TypeLayout2
    {
        @auto,
        sequential,
        @explicit,
    }

    enum TypeClassSemantics
    {
        @class,
        @interface,
    }

    struct DecodedTypeAttributes
    {
        public readonly TypeVisibility visibility;
        public readonly TypeLayout2 layout;
        public readonly TypeClassSemantics class_semantics;
        public readonly bool is_abstract;
        public readonly bool is_sealed;

        public DecodedTypeAttributes(TypeAttributes attrs)
        {
            TypeAttributes visibility_attr = attrs & TypeAttributes.VisibilityMask;
            this.visibility = visibility_attr switch
            {
                TypeAttributes.NotPublic => TypeVisibility.not_public,
                TypeAttributes.Public => TypeVisibility.@public,
                TypeAttributes.NestedPublic => TypeVisibility.nested_public,
                TypeAttributes.NestedPrivate => TypeVisibility.nested_private,
                TypeAttributes.NestedFamANDAssem => TypeVisibility.nested_fam_and_assem,
                TypeAttributes.NestedAssembly => TypeVisibility.nested_assembly,
                TypeAttributes.NestedFamily => TypeVisibility.nested_family,
                TypeAttributes.NestedFamORAssem => TypeVisibility.nested_fam_or_assem,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute visibility {0}", visibility_attr)),
            };
            TypeAttributes layout_attr = attrs & TypeAttributes.LayoutMask;
            this.layout = layout_attr switch
            {
                TypeAttributes.AutoLayout => TypeLayout2.@auto,
                TypeAttributes.SequentialLayout => TypeLayout2.sequential,
                TypeAttributes.ExplicitLayout => TypeLayout2.@explicit,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute layout {0}", layout_attr)),
            };
            TypeAttributes class_semantics_attr = attrs & TypeAttributes.ClassSemanticsMask;
            this.class_semantics = class_semantics_attr switch
            {
                TypeAttributes.Class => TypeClassSemantics.@class,
                TypeAttributes.Interface => TypeClassSemantics.@interface,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute class semantics {0}", class_semantics_attr)),
            };
            this.is_abstract = (attrs & TypeAttributes.Abstract) != 0;
            this.is_sealed = (attrs & TypeAttributes.Sealed) != 0;
        }

        public override string ToString()
        {
            return string.Format(
                "Visibility={0} Layout={1} ClassSemantics={2} Abstract={3} Sealed={4}",
                this.visibility,
                this.layout,
                this.class_semantics,
                this.is_abstract,
                this.is_sealed);
        }
    }

    public static readonly string[] zig_keywords = new string[]
    {
        "align",
        "allowzero",
        "and",
        "anyframe",
        "anytype",
        "asm",
        "async",
        "await",
        "break",
        "callconv",
        "catch",
        "comptime",
        "const",
        "continue",
        "defer",
        "else",
        "enum",
        "errdefer",
        "error",
        "export",
        "extern",
        "false",
        "fn",
        "for",
        "if",
        "inline",
        "noalias",
        "nosuspend",
        "noinline",
        "null",
        "opaque",
        "or",
        "orelse",
        "packed",
        "pub",
        "resume",
        "return",
        "linksection",
        "struct",
        "suspend",
        "switch",
        "test",
        "threadlocal",
        "true",
        "try",
        "undefined",
        "union",
        "unreachable",
        "usingnamespace",
        "var",
        "volatile",
        "while",
    };
}
