#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable SA1306 // Field names should begin with lower-case letter
namespace ZigWin32
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Reflection.Metadata;
    using System.Reflection.PortableExecutable;
    using System.Text;
    using System.Threading;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    public class ZigGenerator
    {
        private const string WindowsWin32NamespacePrefix = "Windows.Win32.";
        private const string AutogeneratedMessage = "//! NOTE: this source file is autogenerated, DO NOT MODIFY";
        private const string Win32Zig = @"
pub const api = @import(""win32/api.zig"");
// TODO glue? header?

test """" {
    @import(""std"").testing.refAllDecls(@This());
}
";

        private readonly MetadataReader mr;
        private readonly CancellationToken cancel_token;
        private readonly Dictionary<string, List<TypeGenInfo>> namespace_map = new Dictionary<string, List<TypeGenInfo>>();
        private readonly Dictionary<TypeDefinitionHandle, TypeGenInfo> type_map = new Dictionary<TypeDefinitionHandle, TypeGenInfo>();

        private ZigGenerator(MetadataReader mr, CancellationToken cancel_token)
        {
            this.mr = mr;
            this.cancel_token = cancel_token;
            foreach (TypeDefinitionHandle type_def_handle in this.mr.TypeDefinitions)
            {
                TypeGenInfo type_info = new TypeGenInfo(this.mr, type_def_handle);
                this.type_map.Add(type_def_handle, type_info);

                List<TypeGenInfo>? namespace_list;
                if (!this.namespace_map.TryGetValue(type_info.@namespace, out namespace_list))
                {
                    namespace_list = new List<TypeGenInfo>();
                    this.namespace_map.Add(type_info.@namespace, namespace_list);
                }

                namespace_list.Add(type_info);
            }
        }

        // returns: the number of apis generated
        public static uint Generate(Stream metadata_stream, string out_dir, CancellationToken cancel_token)
        {
            using PEReader pe_reader = new PEReader(metadata_stream);
            MetadataReader mr = pe_reader.GetMetadataReader();
            ZigGenerator generator = new ZigGenerator(mr, cancel_token);
            Api[] apis = mr.TypeDefinitions.Select(mr.GetTypeDefinition)
                .Where(td => mr.StringComparer.Equals(td.Name, "Apis"))
                .Select(td => new Api(mr, td)).ToArray();
            {
                var win32_filename = Path.Combine(out_dir, "win32.zig");
                using var file_stream = new FileStream(win32_filename, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                out_file.Write(Win32Zig);
            }

            string win32_dir = Path.Combine(out_dir, "win32");
            Directory.CreateDirectory(win32_dir);

            string api_dir = Path.Combine(win32_dir, "api");
            Directory.CreateDirectory(api_dir);

            foreach (Api api in apis)
            {
                string filepath = Path.Combine(api_dir, api.base_filename);
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                Console.WriteLine("Api: {0}", api.name);
                generator.GenerateApi(out_file, api);
            }

            {
                string filepath = Path.Combine(win32_dir, "api.zig");
                using var file_stream = new FileStream(filepath, FileMode.Create, FileAccess.Write, FileShare.Read);
                using var out_file = new StreamWriter(file_stream, Encoding.UTF8);
                out_file.WriteLine(AutogeneratedMessage);
                foreach (Api api in apis)
                {
                    out_file.WriteLine(@"pub const {0} = @import(""api/{1}"");", api.name_lower, api.base_filename);
                }

                out_file.WriteLine(@"test """" {{");
                out_file.WriteLine(@"    const api_count = {0};", apis.Length);
                out_file.WriteLine(@"    @setEvalBranchQuota(api_count);");
                out_file.WriteLine(@"    @import(""std"").testing.refAllDecls(@This());");
                out_file.WriteLine(@"}}");
            }

            return (uint)apis.Length;
        }

        private void GenerateApi(StreamWriter out_file, Api api)
        {
            out_file.WriteLine(AutogeneratedMessage);

            uint type_count = 0;
            if (this.namespace_map.TryGetValue(api.@namespace, out List<TypeGenInfo>? type_infos))
            {
                foreach (TypeGenInfo type_info in type_infos)
                {
                    this.cancel_token.ThrowIfCancellationRequested();
                    if (type_info.name == "Apis")
                    {
                        continue;
                    }
                    this.GenerateType(out_file, type_info);
                    type_count += 1;
                }
            }

            uint const_count = 0;
            foreach (FieldDefinitionHandle field_def in api.type_def.GetFields())
            {
                this.cancel_token.ThrowIfCancellationRequested();
                this.GenerateConstant(out_file, field_def);
                const_count += 1;
            }

            out_file.WriteLine("test \"\" {{");
            out_file.WriteLine("    const type_export_count = {0};", type_count);
            out_file.WriteLine("    const constant_export_count = {0};", const_count);
            out_file.WriteLine("    @setEvalBranchQuota(type_export_count + constant_export_count + 2); // TODO: why do I need these extra 2?");
            out_file.WriteLine("    @import(\"std\").testing.refAllDecls(@This());");
            out_file.WriteLine("}}");
        }

        private void GenerateType(StreamWriter out_file, TypeGenInfo type_info)
        {
            out_file.WriteLine("// --------------------------------------------------------");
            out_file.WriteLine("// Type: {0}", type_info.name);
            out_file.WriteLine("// Nested: {0}", type_info.def.IsNested);

            DecodedTypeAttributes attrs = new DecodedTypeAttributes(type_info.def.Attributes);

            out_file.WriteLine("// Attributes: {0}", attrs);

            TypeGenInfo? optional_declaring_type = null;
            if (type_info.def.IsNested)
            {
                TypeGenInfo declaring_type = this.type_map[type_info.def.GetDeclaringType()];
                optional_declaring_type = declaring_type;
                out_file.WriteLine("// DeclaringType: {0} (namespace={1})", declaring_type.name, declaring_type.@namespace);
            }
            else
            {
                Debug.Assert(type_info.def.GetDeclaringType().IsNil, "unexpected data");
                out_file.WriteLine("// DeclaringType: <null>");
            }

            /*
             * TODO: look at these Methods on TypeDefinition as well
            type_info.def.GetCustomAttributes()
            type_info.def.GetDeclarativeSecurityAttributes()
            public EventDefinitionHandleCollection GetEvents();
            public FieldDefinitionHandleCollection GetFields();
            public GenericParameterHandleCollection GetGenericParameters();
            public InterfaceImplementationHandleCollection GetInterfaceImplementations();
            public TypeLayout GetLayout();
            public MethodImplementationHandleCollection GetMethodImplementations();
            public MethodDefinitionHandleCollection GetMethods();
            // Summary:
            //     Returns an array of types nested in the specified type.
            // Returns:
            //     An immutable array of type definition handles that represent types nested in
            //     the specified type.
            public ImmutableArray<TypeDefinitionHandle> GetNestedTypes();
            public PropertyDefinitionHandleCollection GetProperties();
            */

            if (type_info.def.IsNested)
            {
                out_file.WriteLine("// TODO: implement nested type '{0}'", type_info.name);
                return;
            }

            if (attrs.is_abstract)
            {
                out_file.WriteLine("// TODO: implement abstract type '{0}'", type_info.name);
                return;
            }

            if (attrs.visibility != TypeVisibility.@public)
            {
                out_file.WriteLine("// TODO: implement non-public type '{0}'", type_info.name);
                return;
            }

            if (!attrs.is_sealed)
            {
                out_file.WriteLine("// TODO: implement non-sealed type '{0}'", type_info.name);
                return;
            }

            if (attrs.layout == TypeLayout2.@explicit)
            {
                out_file.WriteLine("// TODO: implement explicit-layout type '{0}'", type_info.name);
                return;
            }

            if (attrs.layout == TypeLayout2.@auto)
            {
                out_file.WriteLine("// TODO: implement auto-layout type '{0}'", type_info.name);
                return;
            }

            if (attrs.class_semantics == TypeClassSemantics.@interface)
            {
                out_file.WriteLine("// TODO: implement interface type '{0}'", type_info.name);
                return;
            }

            out_file.WriteLine("// HERE");
            /*
            if (type.IsValueType)
            {
                if (type.IsEnum)
                {
                    Debug.Assert(!type.IsGenericType, "enum types can be generic?");
                    GenerateEnum(context, type);
                }
                else
                {
                    GenerateStruct(context, type);
                }
            }
            else if (type.IsInterface)
            {
                GenerateInterface(context, type);
            }
            else
            {
                Debug.Assert(type.IsClass);
                if (typeof(Delegate).IsAssignableFrom(type))
                {
                    GenerateDelegate(context, type);
                }
                else
                {
                    GenerateClass(context, type);
                }
            }
            */
        }

        private void GenerateConstant(StreamWriter out_file, FieldDefinitionHandle fieldDefHandle)
        {
            FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);

            FieldAttributes expected = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal | FieldAttributes.HasDefault;
            if (fieldDef.Attributes != expected)
            {
                throw new InvalidOperationException(string.Format(
                    "Expected Constant FieldDefinition to have these attributes '{0}' but got '{1}'", expected, fieldDef.Attributes));
            }

            Debug.Assert(fieldDef.GetOffset() == -1, "Constant unexpectedly has an offset");
            Debug.Assert(fieldDef.GetRelativeVirtualAddress() == 0, "Constant unexpectedly has non-zero virtual address");

            // TODO: what is this signature?
            byte[] signature = this.mr.GetBlobBytes(fieldDef.Signature);

            // out_file.WriteLine("// signature (TODO: what is this for?) {0} bytes: {1}", signature.Length, BitConverter.ToString(signature));

            // TODO: handle custom attributes
            // TODO: what is fieldDef.GetMarshallingDescriptor?
            foreach (CustomAttributeHandle attrHandle in fieldDef.GetCustomAttributes())
            {
                var attr = this.mr.GetCustomAttribute(attrHandle);

                // TODO: what to do with this?
                /*
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(GuidAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    guid = Guid.Parse((string)args.FixedArguments[0].Value!);
                }
                */
            }

            // NOTE: fieldDef.GetDeclaringType returns the type that contains the Constant
            //       I will probably use this to know where to put the constant but it has nothing
            //       to do with the type of the constant.
            // TypeGenInfo containingTypeInfo = this.GetTypeGenInfo(fieldDef.GetDeclaringType());
            string name = this.mr.GetString(fieldDef.Name);
            Constant constant = this.mr.GetConstant(fieldDef.GetDefaultValue());
            ZigConstAssign assign = constant.ToZigConstAssign(this.mr);
            if (assign.optional_type == null)
            {
                out_file.WriteLine("pub const {0} = {1};", name, assign.literal);
            }
            else
            {
                out_file.WriteLine("pub const {0} : {1} = {2};", name, assign.optional_type, assign.literal);
            }
        }

        private bool IsAttribute(CustomAttribute attribute, string ns, string name)
        {
            StringHandle actualNamespace, actualName;
            if (attribute.Constructor.Kind == HandleKind.MemberReference)
            {
                MemberReference memberReference = this.mr.GetMemberReference((MemberReferenceHandle)attribute.Constructor);
                TypeReference parentRef = this.mr.GetTypeReference((TypeReferenceHandle)memberReference.Parent);
                actualNamespace = parentRef.Namespace;
                actualName = parentRef.Name;
            }
            else if (attribute.Constructor.Kind == HandleKind.MethodDefinition)
            {
                MethodDefinition methodDef = this.mr.GetMethodDefinition((MethodDefinitionHandle)attribute.Constructor);
                TypeDefinition typeDef = this.mr.GetTypeDefinition(methodDef.GetDeclaringType());
                actualNamespace = typeDef.Namespace;
                actualName = typeDef.Name;
            }
            else
            {
                throw new NotSupportedException("Unsupported attribute constructor kind: " + attribute.Constructor.Kind);
            }

            return this.mr.StringComparer.Equals(actualName, name) && this.mr.StringComparer.Equals(actualNamespace, ns);
        }

        private struct Api
        {
            public readonly TypeDefinition type_def;
            public readonly string @namespace;
            public readonly string name;
            public readonly string name_lower;
            public readonly string base_filename;

            public Api(MetadataReader mr, TypeDefinition type_def)
            {
                this.type_def = type_def;
                this.@namespace = mr.GetString(type_def.Namespace);
                Debug.Assert(
                    this.@namespace.StartsWith(WindowsWin32NamespacePrefix, StringComparison.Ordinal),
                    "an Apis Type was not in the Windows.Win32 namespace");
                this.name = this.@namespace.Substring(WindowsWin32NamespacePrefix.Length);
                this.name_lower = this.name.ToLowerInvariant();
                this.base_filename = this.name_lower + ".zig";
            }
        }
    }

    internal static class GenUtil
    {
        public static ZigConstAssign ToZigConstAssign(this Constant constant, MetadataReader mr)
        {
            return constant.TypeCode.ToZigConstAssign(mr.GetBlobReader(constant.Value));
        }

        public static ZigConstAssign ToZigConstAssign(this ConstantTypeCode typeCode, BlobReader blobReader)
        {
            return typeCode switch
            {
#pragma warning disable SA1025 // Code should not contain multiple whitespace in a row
                ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? new ZigConstAssign("true") : new ZigConstAssign("false"),
                ConstantTypeCode.Char    => new ZigConstAssign(string.Format("'{0}'", blobReader.ReadChar())),
                ConstantTypeCode.SByte   => new ZigConstAssign(string.Format("{0}", blobReader.ReadSByte()),  "i8"),
                ConstantTypeCode.Byte    => new ZigConstAssign(string.Format("{0}", blobReader.ReadByte()),   "u8"),
                ConstantTypeCode.Int16   => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt16()),  "i16"),
                ConstantTypeCode.UInt16  => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt16()), "u16"),
                ConstantTypeCode.Int32   => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt32()),  "i32"),
                ConstantTypeCode.UInt32  => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt32()), "u32"),
                ConstantTypeCode.Int64   => new ZigConstAssign(string.Format("{0}", blobReader.ReadInt64()),  "i64"),
                ConstantTypeCode.UInt64  => new ZigConstAssign(string.Format("{0}", blobReader.ReadUInt64()), "u64"),
                ConstantTypeCode.Single  => GetSingle(blobReader.ReadSingle()),
                ConstantTypeCode.Double  => GetDouble(blobReader.ReadDouble()),
                ConstantTypeCode.String  => GetString(blobReader.ReadConstant(ConstantTypeCode.String)),
                ConstantTypeCode.NullReference => new ZigConstAssign("null"),
#pragma warning restore SA1025 // Code should not contain multiple whitespace in a row
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + typeCode),
            };
            static ZigConstAssign GetString(object? obj)
            {
                return obj is string value ?
                    new ZigConstAssign(string.Format("\"{0}\"", value)) :
                    throw new Exception(string.Format("String constant is not a string? it is: {0}", obj));
            }

            static ZigConstAssign GetSingle(float value)
            {
                return
                    float.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f32)") :
                    float.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f32)") :
                    float.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f32)") :
                    new ZigConstAssign(string.Format("{0}", value), "f32");
            }

            static ZigConstAssign GetDouble(double value)
            {
                return
                    double.IsPositiveInfinity(value) ? new ZigConstAssign("@import(\"std\").math.inf(f64)") :
                    double.IsNegativeInfinity(value) ? new ZigConstAssign("-@import(\"std\").math.inf(f64)") :
                    double.IsNaN(value) ? new ZigConstAssign("@import(\"std\").math.nan(f64)") :
                    new ZigConstAssign(string.Format("{0}", value), "f64");
            }
        }

        public static string ToFlagsThatMatterString(this TypeAttributes attr)
        {
            StringBuilder builder = new StringBuilder();
            string prefix = string.Empty;
            foreach (TypeAttributes attr_def in Enum.GetValues(typeof(TypeAttributes)).Cast<TypeAttributes>())
            {
                if ((attr & attr_def) != 0 && ((int)attr_def).UpToOneBitSet())
                {
                    builder.AppendFormat("{0}{1}({2})", prefix, Enum.GetName(typeof(TypeAttributes), attr_def), (int)attr_def);
                    prefix = ", ";
                }
            }
            return builder.ToString();
        }

        public static bool UpToOneBitSet(this int x)
        {
            return (x & (x - 1)) == 0;
        }
    }

    internal struct TypeGenInfo
    {
        public readonly TypeDefinition def;
        public readonly string name;
        public readonly string @namespace;

        public TypeGenInfo(MetadataReader mr, TypeDefinitionHandle handle)
        {
            this.def = mr.GetTypeDefinition(handle);
            this.name = mr.GetString(this.def.Name);
            this.@namespace = mr.GetString(this.def.Namespace);
        }

        public string Zig
        {
            get { return this.name; }
        }
    }

    internal struct ZigConstAssign
    {
        public readonly string literal;
        public readonly string? optional_type;

        public ZigConstAssign(string literal, string? optional_type = null)
        {
            this.literal = literal;
            this.optional_type = optional_type;
        }
    }

    internal enum TypeVisibility
    {
        not_public,
        @public,
        nested_public,
        nested_private,
        nested_fam_and_assem,
        nested_assembly,
        nested_family,
        nested_fam_or_assem,
    }

    internal enum TypeLayout2
    {
        @auto,
        sequential,
        @explicit,
    }

    internal enum TypeClassSemantics
    {
        @class,
        @interface,
    }

    internal struct DecodedTypeAttributes
    {
        public readonly TypeVisibility visibility;
        public readonly TypeLayout2 layout;
        public readonly TypeClassSemantics class_semantics;
        public readonly bool is_abstract;
        public readonly bool is_sealed;

        public DecodedTypeAttributes(TypeAttributes attrs)
        {
            TypeAttributes visibility_attr = attrs & TypeAttributes.VisibilityMask;
            this.visibility = visibility_attr switch
            {
                TypeAttributes.NotPublic => TypeVisibility.not_public,
                TypeAttributes.Public => TypeVisibility.@public,
                TypeAttributes.NestedPublic => TypeVisibility.nested_public,
                TypeAttributes.NestedPrivate => TypeVisibility.nested_private,
                TypeAttributes.NestedFamANDAssem => TypeVisibility.nested_fam_and_assem,
                TypeAttributes.NestedAssembly => TypeVisibility.nested_assembly,
                TypeAttributes.NestedFamily => TypeVisibility.nested_family,
                TypeAttributes.NestedFamORAssem => TypeVisibility.nested_fam_or_assem,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute visibility {0}", visibility_attr)),
            };
            TypeAttributes layout_attr = attrs & TypeAttributes.LayoutMask;
            this.layout = layout_attr switch
            {
                TypeAttributes.AutoLayout => TypeLayout2.@auto,
                TypeAttributes.SequentialLayout => TypeLayout2.sequential,
                TypeAttributes.ExplicitLayout => TypeLayout2.@explicit,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute layout {0}", layout_attr)),
            };
            TypeAttributes class_semantics_attr = attrs & TypeAttributes.ClassSemanticsMask;
            this.class_semantics = class_semantics_attr switch
            {
                TypeAttributes.Class => TypeClassSemantics.@class,
                TypeAttributes.Interface => TypeClassSemantics.@interface,
                _ => throw new InvalidDataException(string.Format("unknown TypeAttribute class semantics {0}", class_semantics_attr)),
            };
            this.is_abstract = (attrs & TypeAttributes.Abstract) != 0;
            this.is_sealed = (attrs & TypeAttributes.Sealed) != 0;
        }

        public override string ToString()
        {
            return string.Format(
                "Visibility={0} Layout={1} ClassSemantics={2} Abstract={3} Sealed={4}",
                this.visibility,
                this.layout,
                this.class_semantics,
                this.is_abstract,
                this.is_sealed);
        }
    }
}
